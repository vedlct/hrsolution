{"remainingRequest":"C:\\xampp\\htdocs\\hrsolution\\frontend\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\xampp\\htdocs\\hrsolution\\frontend\\node_modules\\@ng-bootstrap\\ng-bootstrap\\datepicker\\datepicker-tools.js","dependencies":[{"path":"C:\\xampp\\htdocs\\hrsolution\\frontend\\node_modules\\@ng-bootstrap\\ng-bootstrap\\datepicker\\datepicker-tools.js","mtime":1540541368619},{"path":"C:\\xampp\\htdocs\\hrsolution\\frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1540541371218},{"path":"C:\\xampp\\htdocs\\hrsolution\\frontend\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1540541362686}],"contextDependencies":[],"result":["import { NgbDate } from './ngb-date';\r\nimport { isDefined } from '../util/util';\r\nexport function isChangedDate(prev, next) {\r\n    return !dateComparator(prev, next);\r\n}\r\nexport function dateComparator(prev, next) {\r\n    return (!prev && !next) || (!!prev && !!next && prev.equals(next));\r\n}\r\nexport function checkMinBeforeMax(minDate, maxDate) {\r\n    if (maxDate && minDate && maxDate.before(minDate)) {\r\n        throw new Error(\"'maxDate' \" + maxDate + \" should be greater than 'minDate' \" + minDate);\r\n    }\r\n}\r\nexport function checkDateInRange(date, minDate, maxDate) {\r\n    if (date && minDate && date.before(minDate)) {\r\n        return NgbDate.from(minDate);\r\n    }\r\n    if (date && maxDate && date.after(maxDate)) {\r\n        return NgbDate.from(maxDate);\r\n    }\r\n    return date;\r\n}\r\nexport function isDateSelectable(date, state) {\r\n    var minDate = state.minDate, maxDate = state.maxDate, disabled = state.disabled, markDisabled = state.markDisabled;\r\n    // clang-format off\r\n    return !(!isDefined(date) ||\r\n        disabled ||\r\n        (markDisabled && markDisabled(date, { year: date.year, month: date.month })) ||\r\n        (minDate && date.before(minDate)) ||\r\n        (maxDate && date.after(maxDate)));\r\n    // clang-format on\r\n}\r\nexport function generateSelectBoxMonths(calendar, date, minDate, maxDate) {\r\n    if (!date) {\r\n        return [];\r\n    }\r\n    var months = calendar.getMonths();\r\n    if (minDate && date.year === minDate.year) {\r\n        var index = months.findIndex(function (month) { return month === minDate.month; });\r\n        months = months.slice(index);\r\n    }\r\n    if (maxDate && date.year === maxDate.year) {\r\n        var index = months.findIndex(function (month) { return month === maxDate.month; });\r\n        months = months.slice(0, index + 1);\r\n    }\r\n    return months;\r\n}\r\nexport function generateSelectBoxYears(date, minDate, maxDate) {\r\n    if (!date) {\r\n        return [];\r\n    }\r\n    var start = minDate && minDate.year || date.year - 10;\r\n    var end = maxDate && maxDate.year || date.year + 10;\r\n    return Array.from({ length: end - start + 1 }, function (e, i) { return start + i; });\r\n}\r\nexport function nextMonthDisabled(calendar, date, maxDate) {\r\n    return maxDate && calendar.getNext(date, 'm').after(maxDate);\r\n}\r\nexport function prevMonthDisabled(calendar, date, minDate) {\r\n    var prevDate = calendar.getPrev(date, 'm');\r\n    return minDate && (prevDate.year === minDate.year && prevDate.month < minDate.month ||\r\n        prevDate.year < minDate.year && minDate.month === 1);\r\n}\r\nexport function buildMonths(calendar, date, state, i18n, force) {\r\n    var displayMonths = state.displayMonths, months = state.months;\r\n    // move old months to a temporary array\r\n    var monthsToReuse = months.splice(0, months.length);\r\n    // generate new first dates, nullify or reuse months\r\n    var firstDates = Array.from({ length: displayMonths }, function (_, i) {\r\n        var firstDate = calendar.getNext(date, 'm', i);\r\n        months[i] = null;\r\n        if (!force) {\r\n            var reusedIndex = monthsToReuse.findIndex(function (month) { return month.firstDate.equals(firstDate); });\r\n            // move reused month back to months\r\n            if (reusedIndex !== -1) {\r\n                months[i] = monthsToReuse.splice(reusedIndex, 1)[0];\r\n            }\r\n        }\r\n        return firstDate;\r\n    });\r\n    // rebuild nullified months\r\n    firstDates.forEach(function (firstDate, i) {\r\n        if (months[i] === null) {\r\n            months[i] = buildMonth(calendar, firstDate, state, i18n, monthsToReuse.shift() || {});\r\n        }\r\n    });\r\n    return months;\r\n}\r\nexport function buildMonth(calendar, date, state, i18n, month) {\r\n    if (month === void 0) { month = {}; }\r\n    var minDate = state.minDate, maxDate = state.maxDate, firstDayOfWeek = state.firstDayOfWeek, markDisabled = state.markDisabled, outsideDays = state.outsideDays;\r\n    month.firstDate = null;\r\n    month.lastDate = null;\r\n    month.number = date.month;\r\n    month.year = date.year;\r\n    month.weeks = month.weeks || [];\r\n    month.weekdays = month.weekdays || [];\r\n    date = getFirstViewDate(calendar, date, firstDayOfWeek);\r\n    // month has weeks\r\n    for (var week = 0; week < calendar.getWeeksPerMonth(); week++) {\r\n        var weekObject = month.weeks[week];\r\n        if (!weekObject) {\r\n            weekObject = month.weeks[week] = { number: 0, days: [], collapsed: true };\r\n        }\r\n        var days = weekObject.days;\r\n        // week has days\r\n        for (var day = 0; day < calendar.getDaysPerWeek(); day++) {\r\n            if (week === 0) {\r\n                month.weekdays[day] = calendar.getWeekday(date);\r\n            }\r\n            var newDate = new NgbDate(date.year, date.month, date.day);\r\n            var nextDate = calendar.getNext(newDate);\r\n            var ariaLabel = i18n.getDayAriaLabel(newDate);\r\n            // marking date as disabled\r\n            var disabled = !!((minDate && newDate.before(minDate)) || (maxDate && newDate.after(maxDate)));\r\n            if (!disabled && markDisabled) {\r\n                disabled = markDisabled(newDate, { month: month.number, year: month.year });\r\n            }\r\n            // saving first date of the month\r\n            if (month.firstDate === null && newDate.month === month.number) {\r\n                month.firstDate = newDate;\r\n            }\r\n            // saving last date of the month\r\n            if (newDate.month === month.number && nextDate.month !== month.number) {\r\n                month.lastDate = newDate;\r\n            }\r\n            var dayObject = days[day];\r\n            if (!dayObject) {\r\n                dayObject = days[day] = {};\r\n            }\r\n            dayObject.date = newDate;\r\n            dayObject.context = Object.assign(dayObject.context || {}, {\r\n                date: { year: newDate.year, month: newDate.month, day: newDate.day },\r\n                currentMonth: month.number, disabled: disabled,\r\n                focused: false,\r\n                selected: false\r\n            });\r\n            dayObject.tabindex = -1;\r\n            dayObject.ariaLabel = ariaLabel;\r\n            dayObject.hidden = false;\r\n            date = nextDate;\r\n        }\r\n        weekObject.number = calendar.getWeekNumber(days.map(function (day) { return NgbDate.from(day.date); }), firstDayOfWeek);\r\n        // marking week as collapsed\r\n        weekObject.collapsed = outsideDays === 'collapsed' && days[0].date.month !== month.number &&\r\n            days[days.length - 1].date.month !== month.number;\r\n    }\r\n    return month;\r\n}\r\nexport function getFirstViewDate(calendar, date, firstDayOfWeek) {\r\n    var daysPerWeek = calendar.getDaysPerWeek();\r\n    var firstMonthDate = new NgbDate(date.year, date.month, 1);\r\n    var dayOfWeek = calendar.getWeekday(firstMonthDate) % daysPerWeek;\r\n    return calendar.getPrev(firstMonthDate, 'd', (daysPerWeek + dayOfWeek - firstDayOfWeek) % daysPerWeek);\r\n}\r\n//# sourceMappingURL=datepicker-tools.js.map",null]}